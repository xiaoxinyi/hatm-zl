!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
AddPathToAuthor	author.cc	/^void AuthorTopicUtils::AddPathToAuthor($/;"	f	class:hatm::AuthorTopicUtils
Author	author.cc	/^Author::Author() {	$/;"	f	class:hatm::Author
Author	author.cc	/^Author::Author(int id, int depth) $/;"	f	class:hatm::Author
GetInstance	author.cc	/^AllAuthors& AllAuthors::GetInstance() {$/;"	f	class:hatm::AllAuthors
LogGammaRatio	author.cc	/^double AuthorTopicUtils::LogGammaRatio($/;"	f	class:hatm::AuthorTopicUtils
PermuteWords	author.cc	/^void AuthorUtils::PermuteWords(Author* author) {$/;"	f	class:hatm::AuthorUtils
ProbabilitiesDfs	author.cc	/^void AuthorTopicUtils::ProbabilitiesDfs($/;"	f	class:hatm::AuthorTopicUtils
RemoveAuthorFromPath	author.cc	/^void AuthorTreeUtils::RemoveAuthorFromPath($/;"	f	class:hatm::AuthorTreeUtils
SampleLevels	author.cc	/^void AuthorUtils::SampleLevels($/;"	f	class:hatm::AuthorUtils
UpdateTreeFromAuthor	author.cc	/^void AuthorTreeUtils::UpdateTreeFromAuthor($/;"	f	class:hatm::AuthorTreeUtils
computeLogPrLevel	author.cc	/^void Author::computeLogPrLevel(double gem_mean, $/;"	f	class:hatm::Author
getSumLevelCounts	author.cc	/^int Author::getSumLevelCounts(int depth) const {$/;"	f	class:hatm::Author
hatm	author.cc	/^namespace hatm {$/;"	n	file:
initLevelCounts	author.cc	/^void Author::initLevelCounts(int depth) {$/;"	f	class:hatm::Author
removeWord	author.cc	/^void Author::removeWord(int word) {$/;"	f	class:hatm::Author
AUTHOR_H_	author.h	/^#define AUTHOR_H_$/;"	d
AllAuthors	author.h	/^	AllAuthors() {}$/;"	f	class:hatm::AllAuthors
AllAuthors	author.h	/^class AllAuthors {$/;"	c	namespace:hatm
Author	author.h	/^class Author {$/;"	c	namespace:hatm
AuthorTopicUtils	author.h	/^class AuthorTopicUtils {$/;"	c	namespace:hatm
AuthorTreeUtils	author.h	/^class AuthorTreeUtils {$/;"	c	namespace:hatm
AuthorUtils	author.h	/^class AuthorUtils {$/;"	c	namespace:hatm
addAuthor	author.h	/^	void addAuthor(int id, int depth) { authors_.emplace_back(Author(id, depth)); }$/;"	f	class:hatm::AllAuthors
addWord	author.h	/^	void addWord(int word) { words_.push_back(word); }$/;"	f	class:hatm::Author
authors_	author.h	/^	vector<Author> authors_;$/;"	m	class:hatm::AllAuthors
depth_	author.h	/^	int depth_;$/;"	m	class:hatm::Author
from	author.h	/^	AllAuthors& operator=(const AllAuthors& from) = delete;$/;"	m	class:hatm::AllAuthors
from	author.h	/^	AllAuthors(const AllAuthors& from) = delete;$/;"	m	class:hatm::AllAuthors
getAuthors	author.h	/^	int getAuthors() const { return authors_.size(); }$/;"	f	class:hatm::AllAuthors
getId	author.h	/^	int getId() const { return id_; }$/;"	f	class:hatm::Author
getLevelCounts	author.h	/^	int getLevelCounts(int level) const { return level_counts_.at(level); }$/;"	f	class:hatm::Author
getLogPrLevel	author.h	/^	double getLogPrLevel(int depth) const { return log_pr_level_[depth]; }$/;"	f	class:hatm::Author
getMutableAuthor	author.h	/^	Author* getMutableAuthor(int author_id) { return &authors_[author_id]; }$/;"	f	class:hatm::AllAuthors
getMutablePathTopic	author.h	/^	Topic* getMutablePathTopic(int level) { return path_[level]; }$/;"	f	class:hatm::Author
getScore	author.h	/^	double getScore() const { return score_; }$/;"	f	class:hatm::Author
getWord	author.h	/^	int getWord(int i) { return words_.at(i); }$/;"	f	class:hatm::Author
getWords	author.h	/^	int getWords() const { return words_.size(); }$/;"	f	class:hatm::Author
hatm	author.h	/^namespace hatm {$/;"	n
id_	author.h	/^	int id_;$/;"	m	class:hatm::Author
level_counts_	author.h	/^	vector<int> level_counts_;$/;"	m	class:hatm::Author
log_pr_level_	author.h	/^	std::vector<double> log_pr_level_;$/;"	m	class:hatm::Author
path_	author.h	/^	std::vector<Topic*> path_;$/;"	m	class:hatm::Author
score_	author.h	/^	double score_;$/;"	m	class:hatm::Author
setPathTopic	author.h	/^	void setPathTopic(int level, Topic* topic) {$/;"	f	class:hatm::Author
setScore	author.h	/^	void setScore(double score) { score_ = score; }$/;"	f	class:hatm::Author
setWord	author.h	/^	void setWord(int i, const int& word) { words_.at(i) = word; }$/;"	f	class:hatm::Author
setWords	author.h	/^	void setWords(vector<int>&& words) { words_ = move(words); }$/;"	f	class:hatm::Author
updateLevelCounts	author.h	/^	void updateLevelCounts(int level, int value) {$/;"	f	class:hatm::Author
words_	author.h	/^	vector<int> words_;$/;"	m	class:hatm::Author
BUF_SIZE	corpus.cc	/^#define BUF_SIZE /;"	d	file:
Corpus	corpus.cc	/^Corpus::Corpus()$/;"	f	class:hlda::Corpus
Corpus	corpus.cc	/^Corpus::Corpus(double gem_mean, double gem_scale)$/;"	f	class:hlda::Corpus
GEM_MEAN_STDEV	corpus.cc	/^#define GEM_MEAN_STDEV /;"	d	file:
GEM_STDEV	corpus.cc	/^#define GEM_STDEV /;"	d	file:
GemScore	corpus.cc	/^double CorpusUtils::GemScore($/;"	f	class:hlda::CorpusUtils
PermuteDocuments	corpus.cc	/^void CorpusUtils::PermuteDocuments(Corpus* corpus) {$/;"	f	class:hlda::CorpusUtils
REP_NO_GEM	corpus.cc	/^#define REP_NO_GEM /;"	d	file:
ReadCorpus	corpus.cc	/^void CorpusUtils::ReadCorpus($/;"	f	class:hlda::CorpusUtils
UpdateGemMean	corpus.cc	/^void CorpusUtils::UpdateGemMean(Corpus* corpus) {$/;"	f	class:hlda::CorpusUtils
UpdateGemScale	corpus.cc	/^void CorpusUtils::UpdateGemScale(Corpus* corpus) {$/;"	f	class:hlda::CorpusUtils
hlda	corpus.cc	/^namespace hlda {$/;"	n	file:
CORPUS_H_	corpus.h	/^#define CORPUS_H_$/;"	d
Corpus	corpus.h	/^class Corpus {$/;"	c	namespace:hlda
CorpusUtils	corpus.h	/^class CorpusUtils {$/;"	c	namespace:hlda
addDocument	corpus.h	/^  void addDocument(const Document& document) {$/;"	f	class:hlda::Corpus
all_authors_	corpus.h	/^  AllAuthors& all_authors_;$/;"	m	class:hlda::Corpus
author_no_	corpus.h	/^  int author_no_;$/;"	m	class:hlda::Corpus
documents_	corpus.h	/^  vector<Document> documents_;$/;"	m	class:hlda::Corpus
gem_mean_	corpus.h	/^  double gem_mean_;$/;"	m	class:hlda::Corpus
gem_scale_	corpus.h	/^  double gem_scale_;$/;"	m	class:hlda::Corpus
getAuthorNo	corpus.h	/^  int getAuthorNo() const { return author_no_; }$/;"	f	class:hlda::Corpus
getDocuments	corpus.h	/^  int getDocuments() const { return documents_.size(); }$/;"	f	class:hlda::Corpus
getGemMean	corpus.h	/^  double getGemMean() const { return gem_mean_; }$/;"	f	class:hlda::Corpus
getGemScale	corpus.h	/^  double getGemScale() const { return gem_scale_; }$/;"	f	class:hlda::Corpus
getMutableDocument	corpus.h	/^  Document* getMutableDocument(int i) { return &documents_.at(i); }$/;"	f	class:hlda::Corpus
getWordNo	corpus.h	/^  int getWordNo() const { return word_no_; }$/;"	f	class:hlda::Corpus
hlda	corpus.h	/^namespace hlda {$/;"	n
setAllAuthors	corpus.h	/^  void setAllAuthors(AllAuthors& all_authors) { all_authors_ = all_authors; }$/;"	f	class:hlda::Corpus
setAuthorNo	corpus.h	/^  void setAuthorNo(int author_no) { author_no_ = author_no; }$/;"	f	class:hlda::Corpus
setDocuments	corpus.h	/^  void setDocuments(const vector<Document>& documents) {$/;"	f	class:hlda::Corpus
setGemMean	corpus.h	/^  void setGemMean(double gem_mean) { gem_mean_ = gem_mean; }$/;"	f	class:hlda::Corpus
setGemScale	corpus.h	/^  void setGemScale(double gem_scale) { gem_scale_ = gem_scale; }$/;"	f	class:hlda::Corpus
setWordNo	corpus.h	/^  void setWordNo(int word_no) { word_no_ = word_no; }$/;"	f	class:hlda::Corpus
word_no_	corpus.h	/^  int word_no_;$/;"	m	class:hlda::Corpus
Document	document.cc	/^Document::Document(int id)$/;"	f	class:hatm::Document
GetInstance	document.cc	/^AllWords& AllWords::GetInstance() {$/;"	f	class:hatm::AllWords
PermuteAuthors	document.cc	/^void DocumentUtils::PermuteAuthors(Document* document) {$/;"	f	class:hatm::DocumentUtils
PermuteWords	document.cc	/^void DocumentUtils::PermuteWords(Document* document) {$/;"	f	class:hatm::DocumentUtils
SampleAuthors	document.cc	/^void DocumentUtils::SampleAuthors(Document* document,$/;"	f	class:hatm::DocumentUtils
UpdateAuthorFromWord	document.cc	/^void WordUtils::UpdateAuthorFromWord($/;"	f	class:hatm::WordUtils
Word	document.cc	/^Word::Word(int id) $/;"	f	class:hatm::Word
Word	document.cc	/^Word::Word(int id, int author_id, int level)$/;"	f	class:hatm::Word
hatm	document.cc	/^namespace hatm {$/;"	n	file:
operator ==	document.cc	/^bool Word::operator==(const Word& word) {$/;"	f	class:hatm::Word
AllWords	document.h	/^	AllWords() {}$/;"	f	class:hatm::AllWords
AllWords	document.h	/^class AllWords {$/;"	c	namespace:hatm
DOCUMENT_H_	document.h	/^#define DOCUMENT_H_$/;"	d
Document	document.h	/^class Document {$/;"	c	namespace:hatm
DocumentUtils	document.h	/^class DocumentUtils {$/;"	c	namespace:hatm
Word	document.h	/^class Word {$/;"	c	namespace:hatm
WordUtils	document.h	/^class WordUtils {$/;"	c	namespace:hatm
addAuthorId	document.h	/^	void addAuthorId(const int author_id) { author_ids_.push_back(author_id); } $/;"	f	class:hatm::Document
addWord	document.h	/^	void addWord(int word) { words_.push_back(word); }$/;"	f	class:hatm::Document
addWord	document.h	/^	void addWord(int word_id, int author_id = -1, int level_ = -1) {$/;"	f	class:hatm::AllWords
author_id_	document.h	/^	int author_id_;$/;"	m	class:hatm::Word
author_ids_	document.h	/^	std::vector<int> author_ids_;$/;"	m	class:hatm::Document
from	document.h	/^	AllWords& operator=(const AllWords& from) = delete;$/;"	m	class:hatm::AllWords
from	document.h	/^	AllWords(const AllWords& from) = delete;$/;"	m	class:hatm::AllWords
getAuthorId	document.h	/^	int getAuthorId() const { return author_id_; }$/;"	f	class:hatm::Word
getAuthorId	document.h	/^	int getAuthorId(int i) const { return author_ids_.at(i); }$/;"	f	class:hatm::Document
getAuthors	document.h	/^	int getAuthors() const { return author_ids_.size(); }$/;"	f	class:hatm::Document
getId	document.h	/^	int getId() const { return id_; }$/;"	f	class:hatm::Word
getLevel	document.h	/^	int getLevel() const { return level_; }$/;"	f	class:hatm::Word
getMutableWord	document.h	/^	Word* getMutableWord(int i) { return &words_[i]; }$/;"	f	class:hatm::AllWords
getWord	document.h	/^	int getWord(int i) { return words_.at(i); }$/;"	f	class:hatm::Document
getWordNo	document.h	/^	int getWordNo() const { return word_no_; }$/;"	f	class:hatm::AllWords
getWords	document.h	/^	int getWords() const { return words_.size(); }$/;"	f	class:hatm::Document
hatm	document.h	/^namespace hatm {$/;"	n
id_	document.h	/^	int id_;$/;"	m	class:hatm::Document
id_	document.h	/^	int id_;$/;"	m	class:hatm::Word
level_	document.h	/^	int level_;$/;"	m	class:hatm::Word
setAuthorId	document.h	/^	void setAuthorId(int author_id) { author_id_ = author_id; }$/;"	f	class:hatm::Word
setAuthorIds	document.h	/^	void setAuthorIds(const std::vector<int>& author_ids) { author_ids_ = author_ids; }$/;"	f	class:hatm::Document
setId	document.h	/^	void setId(int id) { id_ = id; }$/;"	f	class:hatm::Word
setLevel	document.h	/^	void setLevel(int level) { level = level_; }$/;"	f	class:hatm::Word
setWordNo	document.h	/^	void setWordNo(const int& word_no) { word_no_ = word_no; }$/;"	f	class:hatm::AllWords
setWords	document.h	/^	void setWords(vector<int>&& words) { words_ = move(words); }$/;"	f	class:hatm::Document
updateLevel	document.h	/^	void updateLevel(int value) { level_ += value; }$/;"	f	class:hatm::Word
updateWordNo	document.h	/^	void updateWordNo(int update) { word_no_ += update; }$/;"	f	class:hatm::AllWords
word_no_	document.h	/^	int word_no_;$/;"	m	class:hatm::AllWords
words_	document.h	/^	vector<Word> words_;$/;"	m	class:hatm::AllWords
words_	document.h	/^	vector<int> words_;$/;"	m	class:hatm::Document
BUF_SIZE	gibbs.cc	/^#define BUF_SIZE /;"	d	file:
DEFAULT_HYPER_LAG	gibbs.cc	/^#define DEFAULT_HYPER_LAG /;"	d	file:
DEFAULT_LEVEL_LAG	gibbs.cc	/^#define DEFAULT_LEVEL_LAG /;"	d	file:
DEFAULT_SAMPLE_GAM	gibbs.cc	/^#define DEFAULT_SAMPLE_GAM /;"	d	file:
DEFAULT_SHUFFLE_LAG	gibbs.cc	/^#define DEFAULT_SHUFFLE_LAG /;"	d	file:
GibbsState	gibbs.cc	/^GibbsState::GibbsState()$/;"	f	class:hatm::GibbsState
InitGibbsState	gibbs.cc	/^void GibbsSampler::InitGibbsState($/;"	f	class:hatm::GibbsSampler
InitGibbsStateRep	gibbs.cc	/^GibbsState* GibbsSampler::InitGibbsStateRep($/;"	f	class:hatm::GibbsSampler
IterateGibbsState	gibbs.cc	/^void GibbsSampler::IterateGibbsState(GibbsState* gibbs_state) {$/;"	f	class:hatm::GibbsSampler
REP_NO	gibbs.cc	/^#define REP_NO /;"	d	file:
ReadGibbsInput	gibbs.cc	/^void GibbsSampler::ReadGibbsInput($/;"	f	class:hatm::GibbsSampler
computeGibbsScore	gibbs.cc	/^double GibbsState::computeGibbsScore() {$/;"	f	class:hatm::GibbsState
hatm	gibbs.cc	/^namespace hatm {$/;"	n	file:
GIBBS_H_	gibbs.h	/^#define GIBBS_H_$/;"	d
GibbsSampler	gibbs.h	/^class GibbsSampler {$/;"	c	namespace:hatm
GibbsState	gibbs.h	/^class GibbsState {$/;"	c	namespace:hatm
corpus_	gibbs.h	/^  Corpus corpus_;$/;"	m	class:hatm::GibbsState
eta_score_	gibbs.h	/^  double eta_score_;$/;"	m	class:hatm::GibbsState
gamma_score_	gibbs.h	/^  double gamma_score_;$/;"	m	class:hatm::GibbsState
gem_score_	gibbs.h	/^  double gem_score_;$/;"	m	class:hatm::GibbsState
getEtaScore	gibbs.h	/^  double getEtaScore() const { return eta_score_; }$/;"	f	class:hatm::GibbsState
getGammaScore	gibbs.h	/^  double getGammaScore() const { return gamma_score_; }$/;"	f	class:hatm::GibbsState
getGemScore	gibbs.h	/^  double getGemScore() const { return gem_score_; }$/;"	f	class:hatm::GibbsState
getHyperLag	gibbs.h	/^  int getHyperLag() const { return hyper_lag_; }$/;"	f	class:hatm::GibbsState
getIteration	gibbs.h	/^  int getIteration() const { return iteration_; }$/;"	f	class:hatm::GibbsState
getLevelLag	gibbs.h	/^  int getLevelLag() const { return level_lag_; }$/;"	f	class:hatm::GibbsState
getMaxScore	gibbs.h	/^  double getMaxScore() const { return max_score_; }$/;"	f	class:hatm::GibbsState
getMutableCorpus	gibbs.h	/^  Corpus* getMutableCorpus() { return &corpus_; }$/;"	f	class:hatm::GibbsState
getMutableTree	gibbs.h	/^  Tree* getMutableTree() { return &tree_; }$/;"	f	class:hatm::GibbsState
getSampleEta	gibbs.h	/^  int getSampleEta() const { return sample_eta_; }$/;"	f	class:hatm::GibbsState
getSampleGam	gibbs.h	/^  int getSampleGam() const { return sample_gam_; }$/;"	f	class:hatm::GibbsState
getSampleGem	gibbs.h	/^  int getSampleGem() const { return sample_gem_; }$/;"	f	class:hatm::GibbsState
getScore	gibbs.h	/^  double getScore() const { return score_; }$/;"	f	class:hatm::GibbsState
getShuffleLag	gibbs.h	/^  int getShuffleLag() const { return shuffle_lag_; }$/;"	f	class:hatm::GibbsState
hatm	gibbs.h	/^namespace hatm {$/;"	n
hyper_lag_	gibbs.h	/^  int hyper_lag_;$/;"	m	class:hatm::GibbsState
incIteration	gibbs.h	/^  void incIteration(int val) { iteration_ += val; }$/;"	f	class:hatm::GibbsState
iteration_	gibbs.h	/^  int iteration_;$/;"	m	class:hatm::GibbsState
level_lag_	gibbs.h	/^  int level_lag_;$/;"	m	class:hatm::GibbsState
max_score_	gibbs.h	/^  double max_score_;$/;"	m	class:hatm::GibbsState
sample_eta_	gibbs.h	/^  int sample_eta_;$/;"	m	class:hatm::GibbsState
sample_gam_	gibbs.h	/^  int sample_gam_;$/;"	m	class:hatm::GibbsState
sample_gem_	gibbs.h	/^  int sample_gem_;$/;"	m	class:hatm::GibbsState
score_	gibbs.h	/^  double score_;$/;"	m	class:hatm::GibbsState
setCorpus	gibbs.h	/^  void setCorpus(const Corpus& corpus) { corpus_ = corpus; }$/;"	f	class:hatm::GibbsState
setEtaScore	gibbs.h	/^  void setEtaScore(double eta_score) { eta_score_ = eta_score; }$/;"	f	class:hatm::GibbsState
setGammaScore	gibbs.h	/^  void setGammaScore(double gamma_score) { gamma_score_ = gamma_score; }$/;"	f	class:hatm::GibbsState
setGemScore	gibbs.h	/^  void setGemScore(double gem_score) { gem_score_ = gem_score; }$/;"	f	class:hatm::GibbsState
setIteration	gibbs.h	/^  void setIteration(int iteration) { iteration_ = iteration; }$/;"	f	class:hatm::GibbsState
setMaxScore	gibbs.h	/^  void setMaxScore(double max_score) { max_score_ = max_score; }$/;"	f	class:hatm::GibbsState
setSampleEta	gibbs.h	/^  void setSampleEta(int sample_eta) { sample_eta_ = sample_eta; }$/;"	f	class:hatm::GibbsState
setSampleGem	gibbs.h	/^  void setSampleGem(int sample_gem) { sample_gem_ = sample_gem; }$/;"	f	class:hatm::GibbsState
setScore	gibbs.h	/^  void setScore(double score) { score_ = score; }$/;"	f	class:hatm::GibbsState
setTree	gibbs.h	/^  void setTree(const Tree& tree) { tree_ = tree; }$/;"	f	class:hatm::GibbsState
shuffle_lag_	gibbs.h	/^  int shuffle_lag_;$/;"	m	class:hatm::GibbsState
tree_	gibbs.h	/^  Tree tree_;$/;"	m	class:hatm::GibbsState
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
AddChildTopic	topic.cc	/^Topic* TopicUtils::AddChildTopic(Topic* parent_topic) {$/;"	f	class:hatm::TopicUtils
AddTopic	topic.cc	/^Topic* TopicUtils::AddTopic(Topic* parent_topic) {$/;"	f	class:hatm::TopicUtils
EtaScore	topic.cc	/^double TopicUtils::EtaScore(Topic* topic) {$/;"	f	class:hatm::TopicUtils
GammaScore	topic.cc	/^double TopicUtils::GammaScore(Topic* topic) {$/;"	f	class:hatm::TopicUtils
Prune	topic.cc	/^void TopicUtils::Prune(Topic* topic) {$/;"	f	class:hatm::TopicUtils
Remove	topic.cc	/^void TopicUtils::Remove(Topic* topic) {$/;"	f	class:hatm::TopicUtils
SampleDfs	topic.cc	/^Topic* TopicUtils::SampleDfs($/;"	f	class:hatm::TopicUtils
SampleTopic	topic.cc	/^Topic* TopicUtils::SampleTopic(Topic* root, double log_sum) {$/;"	f	class:hatm::TopicUtils
Topic	topic.cc	/^Topic::Topic(const Topic& from, Topic* parent, Tree* tree)$/;"	f	class:hatm::Topic
Topic	topic.cc	/^Topic::Topic(int level, Topic* parent, Tree* tree, int corpus_word_no)$/;"	f	class:hatm::Topic
hatm	topic.cc	/^namespace hatm {$/;"	n	file:
updateWordCount	topic.cc	/^void Topic::updateWordCount(int word_id, int update) {$/;"	f	class:hatm::Topic
~Topic	topic.cc	/^Topic::~Topic() {$/;"	f	class:hatm::Topic
TOPIC_H_	topic.h	/^#define TOPIC_H_$/;"	d
Topic	topic.h	/^class Topic {$/;"	c	namespace:hatm
TopicUtils	topic.h	/^class TopicUtils {$/;"	c	namespace:hatm
addChild	topic.h	/^  void addChild(Topic* child) { children_.push_back(child); }$/;"	f	class:hatm::Topic
author_no_	topic.h	/^	int author_no_;$/;"	m	class:hatm::Topic
children_	topic.h	/^	vector<Topic*> children_;$/;"	m	class:hatm::Topic
corpus_word_no_	topic.h	/^	int corpus_word_no_;$/;"	m	class:hatm::Topic
from	topic.h	/^  Topic& operator=(const Topic& from) = delete;$/;"	m	class:hatm::Topic
from	topic.h	/^  Topic(const Topic& from) = delete;$/;"	m	class:hatm::Topic
getAuthorNo	topic.h	/^  int getAuthorNo() const { return author_no_; }$/;"	f	class:hatm::Topic
getChildren	topic.h	/^  int getChildren() const { return children_.size(); }$/;"	f	class:hatm::Topic
getCorpusWordNo	topic.h	/^  int getCorpusWordNo() const { return corpus_word_no_; }$/;"	f	class:hatm::Topic
getLevel	topic.h	/^  int getLevel() const { return level_; }$/;"	f	class:hatm::Topic
getLgamWordCountEta	topic.h	/^  double getLgamWordCountEta(int word_id) const {$/;"	f	class:hatm::Topic
getLogPrWord	topic.h	/^  double getLogPrWord(int word_id) const { return log_pr_word_[word_id]; }$/;"	f	class:hatm::Topic
getMutableChild	topic.h	/^  Topic* getMutableChild(int i) { return children_.at(i); }$/;"	f	class:hatm::Topic
getMutableParent	topic.h	/^	Topic* getMutableParent() { return parent_; }$/;"	f	class:hatm::Topic
getMutableTree	topic.h	/^  Tree* getMutableTree() { return tree_; }$/;"	f	class:hatm::Topic
getProbability	topic.h	/^  double getProbability() const { return probability_; }$/;"	f	class:hatm::Topic
getScaling	topic.h	/^  double getScaling() const { return scaling_; }$/;"	f	class:hatm::Topic
getTopicWordNo	topic.h	/^  int getTopicWordNo() const { return topic_word_no_; }$/;"	f	class:hatm::Topic
getTree	topic.h	/^  const Tree& getTree() const { return *tree_; }$/;"	f	class:hatm::Topic
getWordCount	topic.h	/^  int getWordCount(int word_id) const { return word_counts_[word_id]; }$/;"	f	class:hatm::Topic
hatm	topic.h	/^namespace hatm {$/;"	n
id_	topic.h	/^	int id_;$/;"	m	class:hatm::Topic
incAuthorNo	topic.h	/^  void incAuthorNo(int val) { author_no_ += val; }$/;"	f	class:hatm::Topic
level_	topic.h	/^	int level_;$/;"	m	class:hatm::Topic
lgam_word_count_eta_	topic.h	/^	vector<double> lgam_word_count_eta_;$/;"	m	class:hatm::Topic
log_pr_word_	topic.h	/^	vector<double> log_pr_word_;$/;"	m	class:hatm::Topic
parent_	topic.h	/^	Topic* parent_;$/;"	m	class:hatm::Topic
probability_	topic.h	/^	double probability_;$/;"	m	class:hatm::Topic
removeLastChild	topic.h	/^  void removeLastChild() { children_.pop_back(); }$/;"	f	class:hatm::Topic
scaling_	topic.h	/^	double scaling_;$/;"	m	class:hatm::Topic
setChild	topic.h	/^  void setChild(int i, Topic* child) { children_.at(i) = child; }$/;"	f	class:hatm::Topic
setParent	topic.h	/^  void setParent(Topic* parent) { parent_ = parent; }$/;"	f	class:hatm::Topic
setProbability	topic.h	/^  void setProbability(double probability) { probability_ = probability; }$/;"	f	class:hatm::Topic
topic_word_no_	topic.h	/^	int topic_word_no_;$/;"	m	class:hatm::Topic
tree_	topic.h	/^	Tree* tree_;$/;"	m	class:hatm::Topic
word_counts_	topic.h	/^	vector<int> word_counts_;$/;"	m	class:hatm::Topic
ETA_STDEV	tree.cc	/^#define ETA_STDEV /;"	d	file:
GAM_STDEV	tree.cc	/^#define GAM_STDEV /;"	d	file:
REP_NO_ETA	tree.cc	/^#define REP_NO_ETA /;"	d	file:
Tree	tree.cc	/^Tree::Tree()$/;"	f	class:hatm::Tree
Tree	tree.cc	/^Tree::Tree(const Tree& from)$/;"	f	class:hatm::Tree
Tree	tree.cc	/^Tree::Tree(int depth,$/;"	f	class:hatm::Tree
UpdateEta	tree.cc	/^void TreeUtils::UpdateEta(Tree* tree) {$/;"	f	class:hatm::TreeUtils
hatm	tree.cc	/^namespace hatm {$/;"	n	file:
operator =	tree.cc	/^Tree& Tree::operator =(const Tree& from) {$/;"	f	class:hatm::Tree
~Tree	tree.cc	/^Tree::~Tree() {$/;"	f	class:hatm::Tree
TREE_H_	tree.h	/^#define TREE_H_$/;"	d
Tree	tree.h	/^class Tree {$/;"	c	namespace:hatm
TreeUtils	tree.h	/^class TreeUtils {$/;"	c	namespace:hatm
depth_	tree.h	/^  int depth_;$/;"	m	class:hatm::Tree
eta_	tree.h	/^  vector<double> eta_;$/;"	m	class:hatm::Tree
getDepth	tree.h	/^  int getDepth() const { return depth_; }$/;"	f	class:hatm::Tree
getEta	tree.h	/^  double getEta(int i) const { return eta_[i]; }$/;"	f	class:hatm::Tree
getMutableRootTopic	tree.h	/^  Topic* getMutableRootTopic() { return root_topic_; }$/;"	f	class:hatm::Tree
getNextId	tree.h	/^  int getNextId() const { return next_id_; }$/;"	f	class:hatm::Tree
getScalingScale	tree.h	/^  double getScalingScale() const { return scaling_scale_; }$/;"	f	class:hatm::Tree
getScalingShape	tree.h	/^  double getScalingShape() const { return scaling_shape_; }$/;"	f	class:hatm::Tree
hatm	tree.h	/^namespace hatm {$/;"	n
incNextId	tree.h	/^  void incNextId(int val) { next_id_ += val; }$/;"	f	class:hatm::Tree
next_id_	tree.h	/^  int next_id_;$/;"	m	class:hatm::Tree
root_topic_	tree.h	/^  Topic* root_topic_;$/;"	m	class:hatm::Tree
scaling_scale_	tree.h	/^  double scaling_scale_;$/;"	m	class:hatm::Tree
scaling_shape_	tree.h	/^  double scaling_shape_;$/;"	m	class:hatm::Tree
setEta	tree.h	/^  void setEta(int i, double value) { eta_[i] = value; }$/;"	f	class:hatm::Tree
setRootTopic	tree.h	/^  void setRootTopic(Topic* root_topic) { root_topic_ = root_topic; }$/;"	f	class:hatm::Tree
InitRandomNumberGen	utils.cc	/^void Utils::InitRandomNumberGen(long rng_seed) {$/;"	f	class:hatm::Utils
LogSum	utils.cc	/^double Utils::LogSum(double log_a, double log_b) {$/;"	f	class:hatm::Utils
RANDNUMGEN	utils.cc	/^gsl_rng* Utils::RANDNUMGEN = NULL;$/;"	m	class:hatm::Utils	file:
RandGauss	utils.cc	/^double Utils::RandGauss(double mean, double stdev) {$/;"	f	class:hatm::Utils
RandNo	utils.cc	/^double Utils::RandNo() {$/;"	f	class:hatm::Utils
SampleFromLogPr	utils.cc	/^int Utils::SampleFromLogPr(const vector<double>& log_pr) {$/;"	f	class:hatm::Utils
Shuffle	utils.cc	/^void Utils::Shuffle(gsl_permutation* permutation, int size) {$/;"	f	class:hatm::Utils
Sum	utils.cc	/^double Utils::Sum(const vector<double>& v) {$/;"	f	class:hatm::Utils
hatm	utils.cc	/^namespace hatm {$/;"	n	file:
RANDNUMGEN	utils.h	/^  static gsl_rng* RANDNUMGEN;$/;"	m	class:hatm::Utils
UTILS_H_	utils.h	/^#define UTILS_H_$/;"	d
Utils	utils.h	/^class Utils {$/;"	c	namespace:hatm
hatm	utils.h	/^namespace hatm {$/;"	n
